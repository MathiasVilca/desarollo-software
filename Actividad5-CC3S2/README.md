OS: Ubuntu 24.04.3 LTS
Shell(Bash): 5.2.21(1)-release
make: GNU Make 4.3
tar: (GNU tar) 1.35
python3: Python 3.12.3
sha256sum: (GNU coreutils) 9.4

1.1.-
1. `make help` primero usa `grep` para hallar todas las lineas del makefile (almacenadas en `$MAKEFILE_LIST` ya que este contiene el ultimo makefile analizado por make) las cuales cumplen la expresión regular: `^[a-zA-Z0-9_-]+:.*?## `, la cual solo agarra las lineas de los targets del makefile, excepto `$(OUT_DIR)/hello.txt: $(SRC_DIR)/hello.py` debido a que en el inicio contiene `$`, estas lineas luego las pasa por el pipeline a `awk`, que se encarga de extraer tanto el nombre del target y la descripción presente en el comentario de la misma linea (tomando `:##` como separadores y tomando la primera y tercera columna), usando `printf` para imprimirlas. `.DEFAULT_GOAL := help` toma el target help como el elegido por defecto, osea que si se corre `make` sin ningun target, se elegirá este por defecto. `.PHONY` sirve para aclarar al `make` que sus valores son tareas y no archivos, para que siempre corra los targets incluso si ya existe un archivo con el mismo nombre que uno de los targets.
2. Target tiene como dependencia `$(OUT_DIR)/hello.txt`, lo cual puede ser un archivo de texto en `$(OUT_DIR)` u otro target, dependiendo si el primero existe o no. En la primera corrida el target `build` ejecuta otro target `$(OUT_DIR)/hello.txt` ya que no existe ese archivo objetivo, el cual termina creando `out/hello.txt` gracias a `$(PYTHON) $< > $@`, usando la variable `$@` la cual toma el nombre del target generado, y `$<` que toma la primera dependencia, en este caso el archivo `$(SRC_DIR)/hello.py` que genera el texto de `hello.txt` . Al correrlo por segunda vez, el archivo no reconstruye el target del mismo nombre, ya que su dependencia `out/hello.txt` existe y no ha cambiado (verificado por la marca de tiempo). Este archivo no hace nada lo cual verifica la idempotencia del `build`, ya que siempre que exista su dependencia `out/hello.txt` y esta no haya sido modificada, este no hará nada (la receta del build esta vacia).
3. `-e ` se encarga de que bash salga si cualquier comando tiene un estado de salida diferente de 0 (evidenciado en el ejemplo, que para al encontrar un codigo de salida de 2, detiene ejecución, lo que no crea el archivo), esto en bash esta desactivado por defecto lo cual puede ser critico para un script ya que si se continua de forma exitosa, el estado de salida al final del script va a ser diferente de 0, `-u` asegura que si se referencia una variable no definida anteriormente, el programa finalice. `-o pipefail` evita que se oculten errores en una pipeline, ya que estos por defecto retornan el codigo de salida del último comando, lo cual puede llevar a que errores inesperados (por ejemplo, si en una linea anterior se quiere usar el texto de un archivo y luego ordenarlo, tendrá código de salida 0 incluso si el archivo no existe), por último, `.DELETE_ON_ERROR` elimina el archivo target si ocurre un error en la receta. Los tres primeros ayudan a identificar errores en scripts que pueden pasarse por alto en ejecución y `.DELETE_ON_ERROR` limpia archivo del target (potencialmente corruptos luego del error), lo cual evita que se tenga que eliminar el archivo manualmente.
4. Un fragmento de un makefile se considera como una pieza de código de un makefile el cual se puede usar en otro makefile. Este se puede guardar en un archivo el cual suele ser de extensión `.mk`. Basandose en eso, un fragmento resultante se puede considerar como aquella pieza de código resultante de correr un makefile. En el ejemplo, `make -n` solo muestra las instrucciones de `build` sin ejecutarlas, mientras `-n` imprime información de depurado donde se aprecia la toma de decisión del make: al tener el archivo makefile y al ver que no tenia reglas implicitas ni dependencias, no lo reconstruye, luego pasa a revisar lo mismo para build: primero verifica si existe su dependencia: el archivo objetivo `$(OUT_DIR)/hello.txt`, y al ver que no, revisa las dependencias del objetivo `$(OUT_DIR)/hello.txt`, y luego de verificar que su dependencia `src/hello.py` no tiene otras dependencias ni reglas implícitas y que existe: se decide que se debe reconstruir (debido a que no existe el archivo), lo que genera que se ejecuten las instrucciones vistas con `make -n`, tras lo cual se verifica que se reconstruyo con exito el archivo. Finalmente, al no existir el build, se ejecuta su receta, la cual no hace nada ya que esta vacía.
5. 
