1.1.-
1. `make help` primero usa `grep` para hallar todas las lineas del makefile (almacenadas en `$MAKEFILE_LIST` ya que este contiene el ultimo makefile analizado por make) las cuales cumplen la expresión regular: `^[a-zA-Z0-9_-]+:.*?## `, la cual solo agarra las lineas de los targets del makefile, excepto `$(OUT_DIR)/hello.txt: $(SRC_DIR)/hello.py` debido a que en el inicio contiene `$`, estas lineas luego las pasa por el pipeline a `awk`, que se encarga de extraer tanto el nombre del target y la descripción presente en el comentario de la misma linea (tomando `:##` como separadores y tomando la primera y tercera columna), usando `printf` para imprimirlas. `.DEFAULT_GOAL := help` toma el target help como el elegido por defecto, osea que si se corre `make` sin ningun target, se elegirá este por defecto. `.PHONY` sirve para aclarar al `make` que sus valores son targets y no archivos, para que corra los targets en caso exista un archivo con el mismo nombre que uno de los targets en el folder del makefile
2. Target tiene como dependencia `$(OUT_DIR)/hello.txt`, lo cual puede ser un archivo de texto en `$(OUT_DIR)` u otro target, dependiendo si el primero existe o no. En la primera corrida el target `build` ejecuta otro target `$(OUT_DIR)/hello.txt` ya que no existe ese archivo, el cual termina creando `out/hello.txt`, usando la variable `$@` la cual toma el nombre del target generadO. Al correrlo por segunda vez, el archivo no ejecuta el target del mismo nombre, sino el archivo generado `out/hello.txt`, ya que este existe (verificado por la marca de tiempo) y el target no esta definido en `.PHONY`. Este archivo no hace nada lo cual verifica la idempotencia del `build`, ya que siempre que exista `out/hello.txt` (el cual se genera al ejecutar este target), este no hará nada.
3. `-e ` se encarga de que bash salga si cualquier comando tiene un estado de salida diferente de 0 (evidenciado en el ejemplo, que para al encontrar un codigo de salida de 2, detiene ejecución, lo que no crea el archivo), esto en bash esta desactivado por defecto lo cual puede ser critico para un script ya que si se continua de forma exitosa, el estado de salida al final del script va a ser diferente de 0, `-u` asegura que si se referencia una variable no definida anteriormente, el programa finalice. `-o pipefail` evita que se oculten errores en una pipeline, ya que estos por defecto retornan el codigo de salida del último comando, lo cual puede llevar a que errores inesperados (por ejemplo, si en una linea anterior se quiere usar el texto de un archivo y luego ordenarlo, tendrá código de salida 0 incluso si el archivo no existe), por último, `.DELETE_ON_ERROR` elimina el archivo target si ocurre un error en la receta. Los tres primeros ayudan a identificar errores en scripts que pueden pasarse por alto en ejecución y `.DELETE_ON_ERROR` limpia archivo del target (potencialmente corruptos luego del error), lo cual evita que se tenga que eliminar el archivo manualmente.
4. Se puede interpretar un fragmento como un archivo (fuente : https://www.gnu.org/software/automake/manual/html_node/Include.html), bajo esta lógica, un fragmento resultante se puede interpretar como un archivo resultante de correr un makefile, en el caso del `build`, este sería el archivo `out/hello.txt`, 
5. 
