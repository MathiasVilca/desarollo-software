##Resumen del entorno:
- OS: Ubuntu 24.04.3 LTS
- Shell(Bash): 5.2.21(1)-release
- make: GNU Make 4.3
- tar: (GNU tar) 1.35
- python3: Python 3.12.3
- sha256sum: (GNU coreutils) 9.4

##PARTE 1:
###1.2.-
1. `make help` primero usa `grep` para hallar todas las lineas del makefile (almacenadas en `$MAKEFILE_LIST` ya que este contiene el ultimo makefile analizado por make) las cuales cumplen la expresión regular: `^[a-zA-Z0-9_-]+:.*?## `, la cual solo agarra las lineas de los targets del makefile, excepto `$(OUT_DIR)/hello.txt: $(SRC_DIR)/hello.py` debido a que en el inicio contiene `$`, estas lineas luego las pasa por el pipeline a `awk`, que se encarga de extraer tanto el nombre del target y la descripción presente en el comentario de la misma linea (tomando `:##` como separadores y tomando la primera y tercera columna), usando `printf` para imprimirlas. `.DEFAULT_GOAL := help` toma el target help como el elegido por defecto, osea que si se corre `make` sin ningun target, se elegirá este por defecto. `.PHONY` sirve para aclarar al `make` que sus valores son tareas y no archivos, para que siempre corra los targets incluso si ya existe un archivo con el mismo nombre que uno de los targets.
2. Target tiene como dependencia `$(OUT_DIR)/hello.txt`, lo cual puede ser un archivo de texto en `$(OUT_DIR)` u otro target, dependiendo si el primero existe o no. En la primera corrida el target `build` ejecuta otro target `$(OUT_DIR)/hello.txt` ya que no existe ese archivo objetivo, el cual termina creando `out/hello.txt` gracias a `$(PYTHON) $< > $@`, usando la variable `$@` la cual toma el nombre del target generado, y `$<` que toma la primera dependencia, en este caso el archivo `$(SRC_DIR)/hello.py` que genera el texto de `hello.txt` . Al correrlo por segunda vez, el archivo no reconstruye el target del mismo nombre, ya que su dependencia `out/hello.txt` existe y no ha cambiado (verificado por la marca de tiempo). Este archivo no hace nada lo cual verifica la idempotencia del `build`, ya que siempre que exista su dependencia `out/hello.txt` y esta no haya sido modificada, este no hará nada (la receta del build esta vacia).
3. `-e ` se encarga de que bash salga si cualquier comando tiene un estado de salida diferente de 0 (evidenciado en el ejemplo, que para al encontrar un codigo de salida de 2, detiene ejecución, lo que no crea el archivo), esto en bash esta desactivado por defecto lo cual puede ser critico para un script ya que si se continua de forma exitosa, el estado de salida al final del script va a ser diferente de 0, `-u` asegura que si se referencia una variable no definida anteriormente, el programa finalice. `-o pipefail` evita que se oculten errores en una pipeline, ya que estos por defecto retornan el codigo de salida del último comando, lo cual puede llevar a que errores inesperados (por ejemplo, si en una linea anterior se quiere usar el texto de un archivo y luego ordenarlo, tendrá código de salida 0 incluso si el archivo no existe), por último, `.DELETE_ON_ERROR` elimina el archivo target si ocurre un error en la receta. Los tres primeros ayudan a identificar errores en scripts que pueden pasarse por alto en ejecución y `.DELETE_ON_ERROR` limpia archivo del target (potencialmente corruptos luego del error), lo cual evita que se tenga que eliminar el archivo manualmente.
4. Un fragmento de un makefile se considera como una pieza de código de un makefile el cual se puede usar en otro makefile. Este se puede guardar en un archivo el cual suele ser de extensión `.mk`. Basandose en eso, un fragmento resultante se puede considerar como aquella pieza de código resultante de correr un makefile. En el ejemplo, `make -n` solo muestra las instrucciones de `build` sin ejecutarlas, mientras `-n` imprime información de depurado donde se aprecia la toma de decisión del make: al tener el archivo makefile y al ver que no tenia reglas implicitas ni dependencias, no lo reconstruye, luego pasa a revisar lo mismo para build: primero verifica si existe su dependencia: el archivo objetivo `$(OUT_DIR)/hello.txt`, y al ver que no, revisa las dependencias del objetivo `$(OUT_DIR)/hello.txt`, y luego de verificar que su dependencia `src/hello.py` no tiene otras dependencias ni reglas implícitas y que existe: se decide que se debe reconstruir (debido a que no existe el archivo), lo que genera que se ejecuten las instrucciones vistas con `make -n`, tras lo cual se verifica que se reconstruyo con exito el archivo. Finalmente, al no existir el build, se ejecuta su receta, la cual no hace nada ya que esta vacía.
5. Al tomar la decisión de si rehacer o no el archivo objetivo, el `make` solo revisa la existencia del archivo objetivo, no si este ha cambiado, por eso es que el tocar el target no tiene efecto, en cambio, el cambiar una dependencia del target (en este caso, el `src/hello.py`), el make se ve forzado a rehacer el objetivo. Esto se aprecia al usar `make -d`, el cual pregunta si existe el objetivo, verifica reglas implícitas y por ultimo dependencias, al verificar que hubo un cambio en su marca de tiempo, el objetivo `$(OUT_DIR)/hello.txt` estaría "desactualizado" y por esto se reconstruye
6. Lo que hace `shellcheck` es revisar si hay algún bug o error en un script de shell, en este caso revisa `scripts/run_test.sh` el cual de momento esta vacío y por lo tanto detecta un error, al no encontrar el shebang (`#!`) con el cual se indica la ruta completa del intérprete del script. Mientras tanto, `shfmt` se encarga de formatear los scripts .sh según un estilo por defecto, en este caso, `shfmt -d` muestra las diferencias entre el archivo original y el modificado/formateado por este, en el ejemplo, muestra el como "agregó" una linea vacía a `scripts/run_test.sh`
7. Hashes:
```bash
513feda84378f3b46112a0f326095d77246474532ccffd92f0c4df4b1f13ec30  dist/app.tar.gz
513feda84378f3b46112a0f326095d77246474532ccffd92f0c4df4b1f13ec30  dist/app.tar.gz
```
Notamos que los hashes son exactamente iguales, lo que indica que el archivo es exactamente el mismo luego de empaquetar por segunda vez. La opcion `--sort=name` hace que los directorios se lean en un orden (en este caso por nombre), por lo general, el SO suele entregar entradas de directorio en un orden aleatorio, por lo cual ordenarlos permite que el archivo sea constante.`mtime=@0` establece la fecha de modificación de los ficheros a `mié 31 dic 1969 19:00:00 -05`, el cual es la marca de tiempo desde la cual se mide el Tiempo POSIX, lo cual hace que la fecha de modificación sea constante sin importar cuantas veces se reempaquete. `--numeric-owner` hace que siempre se usen números para nombres de usuario y grupos (usando UIDs y GIDs, respectivamente), los cuales son fijados por `--owner=0 --group=0`, evitando que estos varien, y por último `gzip -n` hace que no se restaure ni el nombre ni la marca de tiempo original, lo cual evita que estos se modifiquen al reempaquetar.
8. El TAB esta para diferenciar las líneas de receta de otras lineas de codigo, como pueden ser los targets o lineas de definición de variables, no tiene que ser necesariamente un tab, de hecho. El caracter que make usa para diferenciar lineas de receta esta en la variable `.RECIPEPREFIX` la cual se puede cambiar a cualquier otro carácter. Para un diagnostico rápido, se puede ubicar la linea causante del error en un editor de texto con lineas numeradas (usando la información dada por el error) y verificar si la indentación del inicio de la linea esta hecha correctamente.

###1.3.-
- Pasa el test y `echo $?` da como resultado 0
- Falla el test por salida inesperada y `$?` tiene valor 2, ya que trap ejecuta `cleanup()` el cual retorna con el mismo código que el último test ejecutado, este tambien restaura `hello.py` en caso su .bak exista
- Al ejecutar `bash -x scripts/run_tests.sh` se aprecia mejor lo anterior, especialmente el como el trap ejecuta `cleanup` pasandole el código de salida del test como argumento, en este caso 2, si se arregla, se ve como pasa el estado 0 al cleanup, y no se restaura hello.py al no existir el .bak
- Efectivamente, al output quedar indefinida, el script comunica en terminal `scripts/run_tests.sh: línea 46: output: variable sin asignar`, esto gracias al `set -u`, lo cual detiene la ejecucion, y el trap devuelve codigo de salida 2

##PARTE 2:
- Al mostrar los comandos, se evidencia el orden `tools > lint > build > test > package`, esto dado por las dependencias de `all` las cuales son justamente estos objetivos en ese orden. En la parte de `build` se evidencia el uso de `$@` y `$<`, los cuales son reemplazados por `out/hello.txt` y `src/hello.py` respectivamente en `python3 src/hello.py > out/hello.txt`
- Despues de localizar las lineas similares "Se considera el archivo objetivo" y "debe reconstruir", se puede notar que `out/hello.txt` no se recompila ya que según las marcas de tiempo, la dependencia 'src/hello.py' es anterior al objetivo 'out/hello.txt', lo cual indica que la dependencia no cambió desde que se construyó o cambió el archivo objetivo por última vez, por lo tanto, no es necesario reconstruir el objetivo. `mkdir -p $(@D)` logra hacer el directorio `out` gracias a que `@D` contiene la parte de directorio del nombre del archivo objetivo sin el slash, el cual al ser `out/hello.txt` equivale a `out`
- Se comprueba fallo de al requerirse GNU tar, mientras tanto, `--sort`, `--numeric-owner` y `--mtime` ayudan con la reproducibilidad al permitir fijar ciertos valores del paquete, (el orden en el que se procesan los directorios, el nombre del usuario dueño via UID y la marca de tiempo de modificación, respectivamente). Estos al ser constantes no cambian al reempaquetar múltiples veces.
- Comparación de ambos hashes (primer empaquetamiento y segundo)
```bash
SHA256_1=6527269e88253fb573312386dda40e33d6d73b6bb28604510fec567afae70240
SHA256_2=6527269e88253fb573312386dda40e33d6d73b6bb28604510fec567afae70240
```
Aquí se evidencia la importancia de `--sort`, `--numeric-owner` y `--mtime` del punto anterior.
- Primera ejecucion: alrededor de 0.9 segundos, Segunda ejecución: alrededor de 0.3 segundos. La principal diferencia entre logs es que solo la primera construye `out/hello.txt`. Justamente por esto la segunda es más rápida, al la dependencia ya estar construida y al ser anterior al objetivo, no se necesita reconstruir el objetivo.
- Se verifica que se uso python 3.12 con el output `python3.12 -m unittest discover -s tests -v`, el artefacto final no cambia
- luego de ejecutar `touch src/hello.py` y `make all`, se rehacen todos los targets en `.PHONY`, al estos ser definidos como tareas, `out/hello.txt` se rehace también al su dependencia `src/hello.py` ser posterior al objetivo. `$(DIST_DIR)/app.tar.gz:` tambien se rehace ya que al rehacerse `out/hello.txt` este termina siendo posterior a este, y al ser una dependencia, se debe rehacer el tar
- Las dependencias evitan condiciones de carrera al estas ser requeridas (se deben construir antes de avanzar con el objetivo), y `mkdir -p $(@D)` asegura que el folder `out` este creado tanto si `build` o `package` llega primero
- luego de ejecutar, se nota que `All checks passed!`, lo cual indica que el script esta escrito correctamente (sin errores de sintaxis), mientras `shfmt` no realizo ningun cambio, lo que indica que ya estaba formateado acorde al estándar de `shfmt`

##PARTE :
